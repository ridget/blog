<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <title>Misadventures in Code</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
    <link href="stylesheets/all.css" rel="stylesheet" type="text/css" />
    <link href='http://fonts.googleapis.com/css?family=Nunito:400,700,300' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Varela+Round' rel='stylesheet' type='text/css'>
  </head>
  <body>
    <div class="hero">
  <div class="hero-inner">
    <div class="hero-copy">
      <h1>Misadventures in Code</h1>
    </div>
  </div>
</div>


    <div id="main" role="main">
      <nav>
  <ul>
    <li>
      <a class="blog-title" href="/">Misadventures in Code</a>
    </li>
  </ul>
</nav>

      
<ul>
      <li>
        <article class="type-system-rounded">
            <h3><a href="/2015/02/17/a-treatise-on-controllers-and-nested-resources.html">A Treatise on Controllers and Nested Resources</a></h3>
            <h5>Feb 17</h5>
            <p><h2 id="decouple-yourself-from-only-one-controller-per-resource">Decouple yourself from only one controller per resource</h2>

<p>I have an uneasy relationship with conditionals, but I am particularly wary of anything that is more than an <code>if</code> and <code>else</code>, especially in a controller. </p>

<p>That's not to say I don't believe they have their place, but I'll always look to try and reach for another option, or hoist the conditional up, rather than maintain them in a given method. You see, the issue I have is that complex conditionals, introduce multiple collaborators into a method, reduce the ability to reason about code, and make the system harder to change. </p>

<p><a href="http://blog.steveklabnik.com/posts/2011-12-30-active-record-considered-harmful">Steve Klabnik</a> also gives some insight into the issue:</p>

<blockquote>
  <p>ActionController relies on instance variables to pass information from the controller to the view. Have you ever seen a 200 line long controller method? I have. Good luck teasing out which instance variables actually get set over the course of all those nested ifs.</p>
</blockquote>

<p>Let's take a look at the below:</p>

<pre><code># app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  def index
    ...
    case
    when @user
      @user.posts
    when @company
      @company.posts
    else
      Post.all
    end
  end
  ...
end
</code></pre>

<p>We can reason that the <code>index</code> method has the role of returning a list of posts, and certainly, for the time being, whilst I feel uneasy about the case statement, at least it's returning a collection of the same kind of object. However, it feels <em>off</em> and is certainly harder to test (yes, I do test my controllers), not to mention, flies in the face of <a href="https://pragprog.com/articles/tell-dont-ask">tell don't ask</a>. </p>

<p>What happens when we start to introduce logic into our views as a result of this case statement though? Where we check for the presence of an instance variable, to determine what and what not to display? If I start reaching for a presenter, this still leaves the underlying problem in our action.</p>

<p>What happens when we introduce authorization and roles into the mix? All of a sudden our method is now involved in determining what to display by virtue of a users role, as well as their scope.</p>

<p>Whilst the tight coupling between our controllers and our views certainly doesn't help, I'm of the strong opinion that by increasing the controllers, we can reduce logic in our views as well as increase code clarity. This is not a new or original concept, <a href="http://www.amazon.com/Rails-AntiPatterns-Refactoring-Addison-Wesley-Professional/dp/0321604814">Rails anti-patterns</a>, describes the same issue </p>

<blockquote>
  <p>At some point - a point that comes more quickly than you might think - it becomes beneficial not to try to keep the same controller for each difference resource path but to instead create a new controller for each nesting.</p>
</blockquote>

<p>Whilst our contrived example may not be at that point just yet, it won't be long before it is.</p>

<p>So let's split these controllers up</p>

<pre><code># app/controllers/posts_controller.rb
class PostsController &lt; ApplicationController
  def index
    Post.all
  end
end

# app/controllers/users/posts_controller.rb
class PostsController &lt; ApplicationController
  def index
    @user.posts
  end
end

# app/controllers/companies/posts_controller.rb
class PostsController &lt; ApplicationController
  def index
    @company.posts
  end
end
</code></pre>

<p>At the cost of more classes, our <em>extremely</em> simple example is now easier to reason about and to change. Shared behaviour can be included via concerns, and views either replaced completely, composed of partials, or we can wrap our collections with presenter objects to properly house the logic that remains in the view layer. We are now further enabled to make changes to our code, without being too concerned about our other actors and we have removed condtionals from our controller actions and pushed the decision making process up to our router. </p>

<h2 id="a-note-on-cancan">A Note on CanCan</h2>

<p><code>load_and_authorize</code> hides the logic that can determine which collection of a given resource to display away. So in our contrived example, we wouldn't necessarily have a case statement, unless we needed a scope on one of our actions. Favouring explicitness over implicitness aside, it obfuscates the conditional, but still has all the downsides. Any changes we make to our controller action, now has to deal with the additional actors, as well as is now harder to reason about when or if a particular parent resource is loaded. This is why im considering a move to <a href="https://github.com/elabs/pundit">pundit</a>, but that's another post.</p>

</p>
        </article>
      </li>
      <li>
        <article class="type-system-rounded">
            <h3><a href="/2014/07/01/getting-started-with-ember-part-2.html">getting started with ember, part 2</a></h3>
            <h5>Jul  1</h5>
            <p><h2 id="hamburger-i-mean-handlebar-helpers">Hamburger, I mean Handlebar Helpers</h2>

<p>Before we get started I'd like to give a huge thank you to <a href="https://twitter.com/geoffreyd">@geoffreyd</a>, he pretty much fixed all my code and set me straight on some really good best practices, not to mention spent an enormous amount of time putting up with my help vampirism. Additionally all the code for this post can be found on <a href="https://github.com/ridget/transactions/tree/section_2">github</a></p>

<p>So far we've displayed our transactions on the page, but the amount property in our transaction model is just using a number to represent its value and we want to format it.
So we're going to utilise a helper method so it's available across our views.</p>

<p>Helpers in ember are not dissimilar to helpers in Rails, particularly in this use case where we're planning on formatting an existing value.
 The main difference is by utilising ember, we can ensure our helper method updates as the values it depends upon changes.</p>

<p>Today we're going to register a new helper and convert our transaction amount to something resembling currency. </p>

<p>Ember CLI gives us a few options to achieve our goals, but in this case what we need is the following:</p>

<pre><code>import Ember from "ember";
export default Ember.Handlebars.makeBoundHelper(function(amount, options){
  var amount = (amount/100).toFixed(2);
  var currencyAmount = "$"+ amount + "";
  return currencyAmount;
}); 
</code></pre>

<p>Insert the above into <code>app/helpers/to-currency.js</code>.</p>

<p>We use <code>makeBoundHelper</code> here instead of just helper or <code>registerBoundHelper</code> due to ember-cli.
Ember-cli utilises the <code>makeBoundHelper</code> and makes it accessible to the ember container, this is outside the scope of this post, but if you'd like to dig a little into our applications internals within the console, run <code>Transactions.__container__</code> within your browser.</p>

<p>The alternative to using this is using <code>registerBoundHelper</code> is that we'd need to take the extra step to define the helper function, then register our helper within <code>app.js</code>.</p>

<p>If we reload our application now we should see our transaction amount looking all pretty.</p>

<h2 id="routes">Routes</h2>

<p>This is where most guides would start discussing Ember controllers and creating new transactions from within. We're not going down that path.</p>

<p>A Route in Ember represents state, which is represented with a url. As we're going to be manipulating data, and thus the state of the current page, we're going to store our actions relating to creating a new transaction in a route. To start though we need to specify a new route for the user to hit.</p>

<pre><code>Router.map(function() {
  this.resource('transactions', { path: '/' }, function(){
    this.route('new'); 
  });
});
</code></pre>

<p>Here we have made <code>/transactions/new</code> available. This, by convention, will ensure Ember generates a <code>TransactionsNewRoute</code>, but we're going to create one of our own and start handling user input. To take user input we need a form, so let's create a new template for our transactions form:</p>

<pre><code>&lt;form {{action "createTransaction" on="submit"}}&gt;
  &lt;label for="transaction-name"&gt;Name:&lt;/label&gt;
  {{input type="text" value=name id="name"}}

  &lt;label for="transaction-amount"&gt;Transaction Amount:&lt;/label&gt;
  {{input value=dollarValue id="comp-currency"}}

  &lt;button type="submit"&gt;Save Transaction&lt;/button&gt;
&lt;/form&gt;
</code></pre>

<p>In Ember, if we don't assign a string to a value, that then becomes available to the context object within the template, bear this in mind when we start to look at our Route object later on.</p>

<p>So now that we have a form, let's make our form save our transactions with a Route:</p>

<pre><code>import Ember from 'ember';

export default Ember.Route.extend({
    model: function(){
        return this.store.createRecord("transaction", { amount: 0, name: 'New Transaction' });
    },

    actions: {
      createTransaction: function(){
        var self = this;
        var transaction = this.controller.get('model');
        // TODO: set date format the way you want it.
        transaction.set('occurredOn', new Date);
        transaction.save().then(function(){
          self.transitionTo('transactions.index');
        });
      }
    }

});
</code></pre>

<p>Ok, there's a lot going on here, so lets break it down.</p>

<p>First up, we instantiate a brand new instance of transaction within the route, place it inside the model hook, and set it with some defaults using the <code>createRecord</code> method. 
This then sends the model to the controller, which if you remember from our first post talks exclusively to the template. </p>

<p>Next is our actions, specifically our <code>createTransaction</code> action. We can define actions within a Route object, a Controller or a View. To make understanding when to use which earlier, if you're dealing with data changes, use the Route, if you're dealing with changes within the object or collection, use a Controller, if you're dealing with interactions between views, use the View.</p>

<p>Within our <code>createTransaction</code> action, we retrieve our controller model, which seems a bit odd as we've defined it above. However we need to explicitly retrieve the model object as it stands from the controller, which as we reminded ourselves above, talks to the template. So here, we get the object as it stands in our form. We then save our new transaction, and make use of promises to 
return to the transactions index once complete.</p>

<p>There's one piece to puzzle missing, how does our <code>dollarValue</code> from our template, map to the <code>amount</code> on our model. The answer is in fact, in our model.</p>

<h2 id="computed-properties">Computed Properties</h2>

<p>One of Ember's most powerful features is computed properties.</p>

<p>It allows you to declare functions as properties on an object. When we create a computed property we defined the properties of the object it depends on at the end of the function, we can also
use this to build a computed property that depends on another computed property. Awesome!</p>

<p>In our case below we have a computed property of <code>dollarValue</code> to map dollar values to cents in our database. When we use this property in our form, it sets the amount to the unformatted amount entered in. So when it comes time to saving the form, it automatically does all the adjustments for us. </p>

<pre><code>var Transaction = DS.Model.extend({
    name: DS.attr('string'),
    amount: DS.attr('number'),
    occurredOn: DS.attr('date'),
    dollarValue: function(key, value, previousValue) {
        var currency;
        if (value !== undefined) {  // set was called
            var amount = Math.round(value * 100);
            currency = accounting.unformat(amount);
            this.set("amount", currency);
        } else {
          currency = this.get('amount');
        }

        // Get the value and return for either set or get.
        amount = (currency/100).toFixed(2);
        return accounting.formatMoney(amount, "");
    }.property('amount')
});
</code></pre>

<h2 id="one-more-thing">One more thing</h2>

<p>There's just one thing we need to do, and that's instantiate an Ember Object Controller so our form gets all the attributes proxied through. So let's create a new <code>TransactionsNew</code> controller:</p>

<pre><code>import Ember from "ember";

// Make TransactionsNewController an ObjectController,·
// so that it will proxy properties. !important
export default Ember.ObjectController.extend({

});
</code></pre>
</p>
        </article>
      </li>
      <li>
        <article class="type-system-rounded">
            <h3><a href="/2014/06/29/getting-started-with-ember-js.html">Getting Started With Ember.js</a></h3>
            <h5>Jun 29</h5>
            <p><h2 id="ember-cli">Ember CLI</h2>
<p>Ember is an opinionated JavaScript framework, it subscribes to the Rails philosophy of convention over configuration and makes it very easy to start building well structured,
rich, client side applications.</p>

<p>Ember cli is a tool used to help build Ember applications, and similarly has a strong opinion on how you should structure and work with your code. Today's blog post is going to be using both of these tools.</p>

<p>As a Rails developer, the urge to utilise the <code>ember-rails</code> gem is pretty high, however I'm of the opinion that you should keep your Ember application separate from your Rails app and Ember cli provides too good a tool to ignore.</p>

<p>Ember cli is a command line tool thats based on the Ember App Kit project, it is meant to function as a replacement to Ember App Kit. It gives us a great project structure out of the box (not unlike when you generate a new Rails project with <code>rails new</code>), and a few handy generators.</p>

<p>To get started, please follow the instructions at <a href="http://iamstef.net/ember-cli/">ember cli</a>, and come back when you're ready to proceed.</p>

<p>We're going to be making a simple budgeting application, we'll take incoming transactions, assign them a name, a date, and a price, and assign them to a category.</p>

<p>To start simply run <code>ember new transactions</code> this will create a new <code>transactions</code> folder and generate the application structure. Already we can run <code>ember server</code> from within our application and navigate to our ember app. </p>

<p>To help us identify what's going on in our application, we're going to navigate to our <code>app.js</code> file and add the following:</p>

<pre><code>var App = Ember.Application.extend({
  ...
  LOG_TRANSITIONS: true,
  LOG_TRANSITIONS_INTERNAL: true
});
</code></pre>

<p>This will assist us in getting a better understanding of what's going on under the hood.</p>

<h2 id="the-router">The Router</h2>
<p>Next we're going to start setting up some of our routes within <code>app/router.js</code>. The Router in Ember, as opposed to individual route objects, is much like a router in Rails. The main point of difference between a router in Rails and a router in Ember is that a route in Ember represents any one of the possible states of your application, which in turn provides a url.</p>

<p>To start we're going to add our first real route, which will display an index of transactions:</p>

<pre><code>Router.map(function() {
  this.resource('transactions', { path: '/' });
});
</code></pre>

<p>Note the addition of the <code>path</code> option, this tells Ember to render the <code>transactions</code> template when visiting the root path of your application.</p>

<p>When you give it a route like the above, it tells Ember that it needs an <code>IndexRoute</code>,
a <code>TransactionsRoute</code> and a <code>TransactionsIndexRoute</code> as well as controllers and templates following the same naming convention eg <code>TransactionsIndexController</code> and  <code>transactions/index</code>. </p>

<p>What Ember will do for you is generate those required routes, controllers and templates for you, so you can continue to develop your application until you need to override the default behaviour within those files.</p>

<h2 id="the-model">The Model</h2>

<p>All this routing needs a model to back it. Once again there's some similarities with Rails here so go ahead and create a model in <code>app/models/transaction.js</code>:</p>

<pre><code>import DS from 'ember-data';

var Transaction = DS.Model.extend({
  name: DS.attr('string'),
  amount: DS.attr('number'),
  occurredOn: DS.attr('date')
});

Transaction.reopenClass({
  FIXTURES: [
  {
    id: 1,
      name: "GYG Burritos",
      amount: "1200",
      occurredOn: "12/04/2014" 
  }
]});

export default Transaction;
</code></pre>

<p>We've imported Ember Data, using the import statement at the top of the page. Ember cli provides us the mechanism for this as it uses ES6 modules.
How this happens is a bit beyond the scope of this post, however ES6 modules are not fully supported yet, so Ember uses some crafty magic to make these available to use across the board.</p>

<p>In addition we have also defined our model, given it some attributes with different types and created an initial fixture for us to work with.
To utilise fixtures, open up <code>app/adapters/application.js</code> and add the following:</p>

<pre><code>import DS from 'ember-data';
export default DS.FixtureAdapter.extend();
</code></pre>

<p>This says to Ember to utilise fixtures as our data source.</p>

<h2 id="a-route">A Route</h2>

<p>Now we want to make sure when we visit the index of our application we see our list of transactions.
To accomplish this, we need to use a route. A route helps define what model should be available to your template when we view our transactions, this is achieved with the <code>model</code> hook in the route.</p>

<p>For our first route, we're going to create the <code>TransactionsRoute</code> in <code>app/routes/transactions.js</code></p>

<pre><code>import Ember from 'ember';
var TransactionsRoute = Ember.Route.extend({
  model: function(){
    return this.store.find('transaction');
  }
});

export default TransactionsRoute;
</code></pre>

<p>Note the import of Ember, this is another Ember cli requirement that whenever we need ember-data or Ember in our files, we import either of those depending on our needs.</p>

<p>We also return our available transactions in our model hook</p>

<h2 id="a-template">A template</h2>

<p>We've setup our routes, our model and some initial data, now we need to display our transactions. So we will setup a <code>transactions</code> template in <code>app/templates/transactions.hbs</code> </p>

<pre><code>&lt;ul&gt;
  {{#each}}
    &lt;li&gt;{{name}} {{amount}} {{occurredOn}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;
</code></pre>

<p>The <code>each</code> here loops through an array of records, and although we only have one transaction to return, this will ensure our data is displayed correctly and will support additional records when we progress to adding them.</p>

<p>Now if we run <code>ember server</code> from our terminal we should see our fixture data displayed for us. </p>

<p>I should take a step back here and explain that even though ember knows to go and find the transactions template, it's the <code>{{outlet}}</code> statement in <code>app/templates/application.hbs</code> which enables the template to bubble up to be displayed.</p>

<p>We'll be utilizing this concept further when we add additional features, but for now our list of transactions can remain in our transactions template.</p>

<p>We'll continue on from here in the next blog post, but for now if you'd like to take a look at the source code, you can find it on <a href="http://github.com/ridget/transactions">github</a></p>

<h2 id="a-note-on-controllers">A Note on Controllers</h2>

<p>We didn't look too closely at Ember Controllers in this post, this will come up in the next post in the series, however ember has created all the controllers we have needed and so far we haven't had to extend their base functionality from what we already have. </p>
</p>
        </article>
      </li>
</ul>


      <footer>
  <ul class="large-column">
    <li><h5 class="heading">Recent Articles</h5></li>
    <li>
      <ol>
            <li>
              <a href="/2015/02/17/a-treatise-on-controllers-and-nested-resources.html">A Treatise on Controllers and Nested Resources</a>
              <span>Feb 17</span>
            </li>
            <li>
              <a href="/2014/07/01/getting-started-with-ember-part-2.html">getting started with ember, part 2</a>
              <span>Jul  1</span>
            </li>
            <li>
              <a href="/2014/06/29/getting-started-with-ember-js.html">Getting Started With Ember.js</a>
              <span>Jun 29</span>
            </li>
      </ol>
    </li>
  </ul>

  <ul class="small-column">
    <li><h5 class="heading">Tags</h5></li>
    <li>
      <ol>
            <li><a href="/tags/js.html">js (2)</a></li>
            <li><a href="/tags/ember-js.html">ember.js (1)</a></li>
            <li><a href="/tags/ember.html">ember (1)</a></li>
            <li><a href="/tags/rails.html">rails (1)</a></li>
            <li><a href="/tags/controllers.html">controllers (1)</a></li>
      </ol>
    </li>
    <ul>
</footer>

    </div>
  </body>
</html>
